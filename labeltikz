#! /usr/bin/env python

"""
Installation instructions: Place this script in your path and make it
executable with "chmod +x labeltikz" (without the quotes).

For usage instructions, see below.

Version 1.1 of 2012/7/13

By Nathan Dunfield : http://dunfield.info

This code is in the public domain.  
"""

help_str = r"""Usage:   labeltikz file

where file in ".eps" file, a ".pdf" file, or bitmap file such as ".png", ".jpg", etc.

A window will appear with image, and simply click on it to generate
the label locations, which are output on the terminal window.  The
resulting LaTeX code is intended for use with the "tikzoverlay" package.  

Requirements:

 * Python with Tkinter.  
 * GhostScript.

On OS X, the is first built in and the others are included with the
MacTeX-2010 distribution: http://www.tug.org/mactex/

On Linux, are all available as standard packages, with the first
called "python-tk" on Ubuntu/Debian and "tkinter" on
Fedora/Mandriva/PCLinuxOS.
"""

prefix_text_1 = r"""% Click on the window that appeared to generate the label
% locations.  When you're done, close the window and then 
% copy everything into your LaTeX file.
"""

prefix_text_2 = r"""
\begin{figure}[htb]
\begin{center}
\begin{tikzoverlay}[scale=1.0]{%s}[font=\small]"""

suffix_text =  "\\end{tikzoverlay}\n\\end{center}\n  \\caption{}\n  \\label{fig-}\n\\end{figure}"

import os, sys, tempfile, string, Tkinter
import argparse 

def is_postscript_file(file_name):
    return os.path.splitext(file_name)[-1].lower() in ['.eps','.pdf']

def convert_file_to_bitmap(in_file, out_file, pixels_per_pt=1):
    # If it's PostScript-based, use GhostScript to convert to a bitmap.
    if is_postscript_file(in_file):
        os.system("gs -sDEVICE=ppmraw -dEPSCrop -dNOPAUSE -dBATCH -dSAFER -q " +
                  "-dAlignToPixels=0 -dTextAlphaBits=4 -dUseCropBox -dGraphicsAlphaBits=4 " + 
                  "-r%d -sOutputFile=%s %s" % (72*pixels_per_pt, out_file, in_file))
    else:
        # Use ImageMagick and pray.
        os.system("convert %s %s" % (in_file, out_file))

        
def label_file(file_to_label, abs_coordinates=False):
    # Start Tk
    root = Tkinter.Tk()

    # Load the image file
    base_name = os.path.splitext(file_to_label)[0]
    image_file = tempfile.mktemp() + ".ppm"
    pixels_per_pt = 2 if is_postscript_file(file_to_label) else 1
    convert_file_to_bitmap(file_to_label, image_file, pixels_per_pt)
    tkpi = Tkinter.PhotoImage(file=image_file)

    W, H = tkpi.width(), tkpi.height()
    x_scale = 100.0/W
  
    # Print the inital TeX code
    prefix = prefix_text_1 + prefix_text_2 % (base_name)
    suffix = suffix_text
    if abs_coordinates:
        prefix = prefix.replace('tikzoverlay', 'tikzoverlayabs')
        suffix = suffix.replace('tikzoverlay', 'tikzoverlayabs')
    print(prefix)

    # Start Tk

    root.geometry('+%d+%d' % (100,100))
    root.geometry('%dx%d' % (W, H))
    root.wm_attributes("-topmost", True)
    
    image_canvas = Tkinter.Canvas(root, width=W, height=H, bd=0, highlightthickness=0)
    image_canvas.create_image( (0,0), anchor="nw", image=tkpi)
    image_canvas.circle_count = 0
    
    def process_click(event):
        x, y = event.x, event.y
        r = 6
        if abs_coordinates:
            xy = '(%.3f,%.3f)' % (x/(1.0*W), (H - y)/(1.0*H))
        else:
            xy = '(%.1f,%.1f)' % (x_scale * x, x_scale*(H - y))
        print( "    \\node[] at %s {$%s$};" % (xy,
                                      string.letters[image_canvas.circle_count % len(string.letters)]) )
        image_canvas.create_oval(x-r, y-r, x+r, y+r,outline="black", fill="red")
        image_canvas.circle_count += 1
        
    image_canvas.bind("<Button>", process_click)
    image_canvas.place(x=0, y=0)
    image_canvas.pack()
    root.title(base_name)
    root.mainloop()

    # Print the rest of the TeX code and clean up
    print( suffix )
    os.remove(image_file)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=help_str,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-a', '--abs', action='store_true', help='Use absolute positioning.')
    parser.add_argument('infiles', nargs='+', type=str)
    args = parser.parse_args()
    for file_to_label in args.infiles:
        if not os.path.exists(file_to_label):
            print("** Sorry, the file you specified (%s) does not exist." % file_to_label )
        else:
            label_file(file_to_label, args.abs)



